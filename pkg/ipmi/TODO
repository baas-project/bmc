Lint and vet everything
Resolve TODOs
Verify SessionV2's String() is not messed up, and if so, convert Operation to also be embedded
How do you handle the Open Session Request
- A series of layers where the hierarchy is meaningless (seems wrong)
- As three slices of *Payload fields in the layer?
- Remember where the responsibility of the layer structs stops. Data marshaling only.
Sessions are inherently stateful. Need to think more holistically about how information negotiated in the session and not available in each packet can be used during decoding.
    Given we call decode on an existing struct, we can set fields on the struct to control how it is decoded.
    Structs should handle (de)serialisation only - getting data into and out of wire format - anything beyond calculating simple checksums is *not* their responsibility - these values should be assigned to fields prior to serialising and interpreted after unserialising.
How do you handle an encrypted payload with gopacket? Need the context of the session to be able to decode it.
    It could be that you decode a packet up to a point, e.g. up to and including the session header to extract session information to look up the right context, then decode the rest with that context using a separate call.
Algorithms, particularly confidentiality, should be an interface such that the session logic never has to branch based on the algorithm. Think about what methods are required.

Check decode logic when user is able to specify payload length or # pad bytes: it should be impossible to make the program panic with an index out of bounds by saying a packet or field is longer than it actually is.
Go through unexporting everything that doesn't have to be exported.

## Low priority
Consider implementing map layer lookup variables as arrays for O(1) lookup. Can get an index value by calling a method on the key struct. type Keyer interface {Key() int}
Reduce duplication between authentication, integrity and confidentiality payload structs.
Implement RC4 confidentiality algorithm for compatibility (most things are likely to use AES - only do this when you've got the low-hanging fruit).



If you see any weirdness, be sure to check TODOs about possibly having to reverse byte order of fields...

Repeatedly checking the length of variable-length packets when decoding is a PITA. We want to be able to request the next N bytes, and have it throw an error if they are not available. Also want to be able to get N bytes from the end of the packet. Non-overlapping.
